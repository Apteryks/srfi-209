<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>SRFI 209: Enumerations and Enumeration Sets</title>
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png">
    <link rel="stylesheet" href="https://srfi.schemers.org/srfi.css" type="text/css">
    <style>pre.example { margin-left: 2em; }</style>
    <meta name="viewport" content="width=device-width, initial-scale=1"></head>
  <body>
    <h1><a href="https://srfi.schemers.org/"><img class="srfi-logo"
src="https://srfi.schemers.org/srfi-logo.svg" alt="SRFI logo" /></a>209:
Enumerations and Enum Sets</h1>

<p>by John Cowan (text), Wolfgang Corcoran-Mathe (implementation)</p>

<h2 id="status">Status</h2>

<p>This SRFI is currently in <em>draft</em> status.  Here is <a href="https://srfi.schemers.org/srfi-process.html">an explanation</a> of each status that a SRFI can hold.  To provide input on this SRFI, please send email to <code><a href="mailto:srfi+minus+209+at+srfi+dotschemers+dot+org">srfi-209@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.  To subscribe to the list, follow <a href="https://srfi.schemers.org/srfi-list-subscribe.html">these instructions</a>.  You can access previous messages via the mailing list <a href="https://srfi-email.schemers.org/srfi-209">archive</a>.</p>
<ul>
  <li>Received: 2020-08-26</li>
  <li>60-day deadline: 2020-10-28</li>
  <li>Draft #1 published: 2020-08-29</li>
  <li>Draft #2 published: 2020-09-25</li>
  <li>Draft #3 published: 2020-09-30</li>
  <li>John Cowan's <a href="https://github.com/johnwcowan/srfi-209">personal
    Git repo for this SRFI</a> for reference while the SRFI is in
    <em>draft</em> status (<a href="https://htmlpreview.github.io/?https://github.com/johnwcowan/srfi-209/blob/master/srfi-209.html">preview</a>)</li>
</ul>


<h2>Abstract</h2>

<p>Enums are objects that serve to form sets of distinct classes
that specify different modes of operation for a procedure.
Their use fosters portable and readable code.</p>

<h2>Issues</h2>

<ul><li>Examples are needed.</li></ul>

<h2 id="rationale">Rationale</h2>

<p>Many procedures in many libraries accept arguments from a finite set
(usually a fairly small one), or subsets of a finite set to describe one or
more modes of operation. Offering a mechanism for dealing with such values
fosters portable and readable code, much as records do for compound values, or
multiple values for procedures computing several results.</p>
<p>In Lisp-family languages, it is traditional to use symbols and lists of
symbols for this purpose. Symbols have at least two disadvantages: they are not
“type-safe”, in the sense that a single symbol may be used in more than one
logically independent universe of flags; and in Scheme symbols do not have
associated values. In C-family languages, enumerations have names and numeric
values, by default consecutive values, but often powers of two or something
externally dictated. However, the name is not accessible at runtime, and
enumeration types are not really disjoint from integer types (in C++ they are
statically distinct).</p>
<p>This SRFI instead provides something related to the <em>enums</em> of Java
version 5 and later. These are objects of a type disjoint from all others that
are grouped into <em>enumeration types</em> (called <em>enum classes</em> in
Java). In Java, each enumeration type is allowed to declare the number and
types of values associated with each object, but in this SRFI an enumeration
object has exactly one value; this is useful when translating from C to record
the numeric value, but has other uses as well. The universes of R6RS correspond
to enum types, but they are not reified.</p>
<p>In this SRFI, each enum has four properties: the enum type to which it
belongs, its name (a symbol), its ordinal (an exact integer), and its value
(any object). An enum type provides access to all the enums that belong to it
by name or ordinal.</p>
<p><em>Enumeration sets</em> are used to represent multiple enums that belong
to the same type. They provide a subset of the operations provided by <a
href="https://srfi.schemers.org/srfi-113/srfi-113.html">SRFI 113</a> general
sets.</p>
<p>Specialized mappings from enums to arbitrary values will be described in a
future SRFI. Meanwhile either general-purpose hash tables from <a
href="https://srfi.schemers.org/srfi-125/srfi-125.html">SRFI 125</a> or
elsewhere, or <a href="https://srfi.schemers.org/srfi-146/srfi-146.html">SRFI
146</a> mappings can be used instead.</p>

<h2 id="specification">Specification</h2>

<h3 id="predicates">Predicates</h3>
<p><code>(enum-type?</code>&nbsp;<em>obj</em><code>)</code></p>
<p>Returns <code>#t</code> if <em>obj</em> is an enum type, and <code>#f</code>
otherwise.</p>
<p><code>(enum?</code>&nbsp;<em>obj</em><code>)</code></p>
<p>Returns <code>#t</code> if <em>obj</em> is an enum, and <code>#f</code>
otherwise.</p>
<p><code>(enum-type-contains?</code>&nbsp;<em>enum-type
enum</em><code>)</code></p>
<p>Returns <code>#t</code> if <em>enum</em> belongs to <em>enum-type</em>, and
<code>#f</code> otherwise.</p>
<pre class="example"><code>(enum-type-contains? color (enum-name-&gt;enum color 'red)) &rArr; #t

(enum-type-contains? pizza (enum-name->enum color 'red)) &rArr; #f
</code></pre>
<p><code>(enum=?</code>&nbsp;<em>enum<sub>0</sub> enum<sub>1</sub> enum</em> …<code>)</code></p>
<p>Returns <code>#t</code> if all the arguments are the same enum
in the sense of <code>eq?</code> (which is equivalent to
having the same name and ordinal) and
<code>#f</code> otherwise. It is an error to apply <code>enum=?</code> to enums
belonging to different enum types.</p>
<pre class="example"><code>(enum=? color-red color-blue) &rArr; #f

(enum=? pizza-funghi (enum-name->enum pizza 'funghi)) &rArr; #t

(enum=? color-red (enum-name-&gt;enum color 'red) color-blue) &rArr; #f
</code></pre>
<p><code>(enum&lt;?</code>&nbsp;<em>enum<sub>0</sub> enum<sub>1</sub> enum</em> …<code>)</code></p>
<p><code>(enum&gt;?</code>&nbsp;<em>enum<sub>0</sub> enum<sub>1</sub> enum</em> …<code>)</code></p>
<p><code>(enum&lt;=?</code>&nbsp;<em>enum<sub>0</sub> enum<sub>1</sub> enum</em> …<code>)</code></p>
<p><code>(enum&gt;=?</code>&nbsp;<em>enum<sub>0</sub> enum<sub>1</sub> enum</em> …<code>)</code></p>
<p>These predicates return <code>#t</code> if their arguments are enums whose
ordinals are in increasing, decreasing, non-decreasing, and non-increasing
order respectively, and <code>#f</code> otherwise. It is an error unless all of
the arguments belong to the same enum type.</p>
<pre class="example"><code>(enum&lt;? (enum-ordinal-&gt;enum color 0) (enum-ordinal-&gt;enum color 1))
 &rArr; #t

(enum&gt;? (enum-ordinal-&gt;enum color 2) (enum-ordinal-&gt;enum color 1)) &rArr; #t

(enum&gt;=? (enum-ordinal-&gt;enum color 2)
         (enum-ordinal-&gt;enum color 1)
         (enum-ordinal-&gt;enum color 1))
 &rArr; #t
</code></pre>
<h3 id="enum-type-constructor">Enum type constructor</h3>
<p><code>(make-enum-type</code>&nbsp;<em>list</em><code>)</code></p>
<p>Returns a newly allocated enum type containing a fixed set of newly
allocated enums. Both enums and enum types are immutable, and it is not
possible to create an enum except as part of creating an enum type.</p>
<p>The elements of <em>list</em> are either symbols or two-element lists, where
each list has a symbol as the first element and any value as the second
element. Each list element causes a single enum to be generated, whose name is
specified by the symbol. It is an error unless all the symbols are distinct
within an enum type. The position of the element in <em>list</em> is the
ordinal of the corresponding enum, so ordinals within an enum type are also
distinct. If a value is given, it becomes the value of the enum; otherwise the
enum’s value is the same as the ordinal.</p>
<p>The following example enum types will be used in examples throughout
this SRFI, with the identifier <em>type</em>-<em>name</em> referring to
the enum of type <em>type</em> with name <em>name</em>.</p>
<pre class="example"><code>(define color
  (make-enum-type '(red orange yellow green cyan blue violet)))

(define pizza
  (make-enum-type '((margherita "tomato and mozzarella")
                    (funghi "mushrooms")
                    (chicago "deep-dish")
                    (hawaiian "pineapple and ham"))))
</code></pre>
<h3 id="enum-accessors">Enum accessors</h3>
<p><code>(enum-type</code>&nbsp;<em>enum</em><code>)</code></p>
<p>Returns the enum type to which <em>enum</em> belongs.</p>
<p><code>(enum-name</code>&nbsp;<em>enum</em><code>)</code></p>
<p>Returns the name (symbol) associated with <em>enum</em>.</p>
<p><code>(enum-ordinal</code>&nbsp;<em>enum</em><code>)</code></p>
<p>Returns the ordinal (exact integer) associated with <em>enum</em>.</p>
<p><code>(enum-value</code>&nbsp;<em>enum</em><code>)</code></p>
<p>Returns the value associated with <em>enum</em>.</p>
<h3 id="enum-finders">Enum finders</h3>
<p>These procedures use an enum type and one of the properties
of an enum to find the enum object.
</p>
<p><code>(enum-name-&gt;enum</code>&nbsp;<em>enum-type
symbol</em><code>)</code></p>
<p>If there exists an enum belonging to <em>enum-type</em> named
<em>symbol</em>, return it; otherwise return <code>#f</code>.</p>
<pre class="example"><code>(enum-name (enum-name-&gt;enum color 'green)) &rArr; green
(enum-name-&gt;enum color 'mushroom) &rArr; #f
</code></pre>
<p><code>(enum-ordinal-&gt;enum</code>&nbsp;<em>enum-type
exact-integer</em><code>)</code></p>
<p>If there exists an enum belonging to <em>enum-type</em> whose ordinal is
<em>exact-integer</em>, return it; otherwise return <code>#f</code>.</p>
<pre class="example"><code>(enum-name (enum-ordinal-&gt;enum color 3)) &rArr; green
(enum-ordinal-&gt;enum color 10) &rArr; #f
</code></pre>
<p>Note: There is no way to find an enum by its value, since values need not be
unique.</p>
<p>The following convenience procedures provide enum-finding followed by access
to a property.</p>
<p><code>(enum-name-&gt;ordinal</code>&nbsp;<em>enum-set
symbol</em><code>)</code></p>
<p>Return the ordinal of the enum belonging to <em>enum-type</em> whose name is
<em>symbol</em>. It is an error if there is no such enum.</p>
<pre class="example"><code>(enum-name-&gt;ordinal color 'blue) &rArr; 5
</code></pre>
<p><code>(enum-name-&gt;value</code>&nbsp;<em>enum-set
symbol</em><code>)</code></p>
<p>Return the value of the enum belonging to <em>enum-type</em> whose name is
<em>symbol</em>. It is an error if there is no such enum.</p>
<pre class="example"><code>(enum-name-&gt;value pizza 'funghi) &rArr; "mushrooms"
(enum-name-&gt;value color 'blue) &rArr; 5
</code></pre>
<p><code>(enum-ordinal-&gt;name</code>&nbsp;<em>enum-set
exact-integer</em><code>)</code></p>
<p>Return the name of the enum belonging to <em>enum-type</em> whose ordinal is
<em>exact-integer</em>. It is an error if there is no such enum.</p>
<pre class="example"><code>(enum-ordinal-&gt;name color 0) &rArr; red
(enum-ordinal-&gt;name pizza 3) &rArr; hawaiian
</code></pre>
<p><code>(enum-ordinal-&gt;value</code>&nbsp;<em>enum-set
exact-integer</em><code>)</code></p>
<p>Return the value of the enum belonging to <em>enum-type</em> whose ordinal
is <em>exact-integer</em>. It is an error if there is no such enum.</p>
<pre class="example"><code>(enum-ordinal-&gt;value pizza 1) &rArr; "mushrooms"
</code></pre>
<h3 id="enumeration-types">Enumeration types</h3>
<p><code>(enum-type-size</code>&nbsp;<em>enum-type</em><code>)</code></p>
<p>Returns an exact integer equal to the number of enums in
<em>enum-type</em>.</p>
<p><code>(enum-min</code>&nbsp;<em>enum-type</em><code>)</code></p>
<p>Returns the enum belonging to <em>enum-type</em> whose ordinal is 0.</p>
<pre class="example"><code>(enum-name (enum-min color)) &rArr; red
(enum-name (enum-min pizza)) &rArr; margherita
</code></pre>
<p><code>(enum-max</code>&nbsp;<em>enum-type</em><code>)</code></p>
<p>Returns the enum belonging to <em>enum-type</em> whose ordinal is equal to
the number of enums in the enum type minus 1.</p>
<pre class="example"><code>(enum-name (enum-max color)) &rArr; violet
(enum-name (enum-max pizza)) &rArr; hawaiian
</code></pre>
<p><code>(enum-type-enums</code>&nbsp;<em>enum-type</em><code>)</code></p>
<p>Returns a list of the enums belonging to <em>enum-type</em> ordered by
increasing ordinal.</p>
<pre class="example"><code>(map enum-name (enum-type-enums pizza)) &rArr;
  (margherita funghi chicago hawaiian)
</code></pre>
<p><code>(enum-type-names</code>&nbsp;<em>enum-type</em><code>)</code></p>
<p>Returns a list of the names of the enums belonging to <em>enum-type</em>
ordered by increasing ordinal.</p>
<pre class="example"><code>(enum-type-names color)
 &rArr; (red orange yellow green cyan blue violet)
</code></pre>
<p><code>(enum-type-values</code>&nbsp;<em>enum-type</em><code>)</code></p>
<p>Returns a list of the values of the enums belonging to <em>enum-type</em>
ordered by increasing ordinal.</p>
<pre class="example"><code>(enum-type-values pizza)
 &rArr; ("tomato and mozzarella" "mushrooms" "deep-dish" "pineapple and ham")
</code></pre>
<h3 id="enum-objects">Enum objects</h3>
<p><code>(enum-next</code>&nbsp;<em>enum</em><code>)</code></p>
<p>Returns the enum that belongs to the same enum-type as <em>enum</em> and has
an ordinal one greater than <em>enum</em>. Returns <code>#f</code> if there is
no such enum.</p>
<pre class="example"><code>(enum-name (enum-next color-red)) &rArr; orange
(enum-next (enum-max color)) &rArr; #f
</code></pre>
<p><code>(enum-prev</code>&nbsp;<em>enum</em><code>)</code></p>
<p>Returns the enum that belongs to the same enum-type as <em>enum</em> and has
an ordinal one less than <em>enum</em>. Returns <code>#f</code> if there is no
such enum.</p>
<pre class="example"><code>(enum-name (enum-prev color-orange)) &rArr; red
(enum-prev (enum-min color)) &rArr; #f
</code></pre>
<h3 id="comparators">Comparators</h3>
<p><code>(make-enum-comparator</code>&nbsp;<em>enum-type</em><code>)</code></p>
<p>Returns a <a href="https://srfi.schemers.org/srfi-128/srfi-128.html">SRFI
128</a> comparator suitable for comparing enums that belong to
<em>enum-type</em>. The comparator contains both an ordering predicate and a
hash function, and orders enums based on their ordinal values.</p>
<pre class="example"><code>(define pizza-comparator (make-enum-comparator pizza))

(comparator-hashable? pizza-comparator) &rArr; #t

(comparator-test-type pizza-comparator pizza-funghi) &rArr; #t

(&lt;? pizza-comparator pizza-margherita pizza-chicago) &rArr; #t
</code></pre>
<h3 id="enum-set-constructors">Enum set constructors</h3>
<p><code>(enum-type-&gt;enum-set</code>&nbsp;<em>enum-type</em><code>)</code></p
>
<p>Returns an enum set containing all the enums that belong to
<em>enum-type</em>.</p>
<pre class="example"><code>(define color-set (enum-type-&gt;enum-set color))

(define pizza-set (enum-type-&gt;enum-set pizza))

(every (lambda (enum)
         (enum-set-contains? pizza-set enum))
       (enum-type-enums pizza))
 &rArr; #t

(enum-set-map-&gt;list enum-name color-set)
 &rArr; (red orange yellow green cyan blue violet)
</code></pre>
<p><code>(enum-set</code>&nbsp;<em>enum</em> …<code>)</code></p>
<p>Returns an enum-set containing the <em>enums</em>. It is an error unless all
of them belong to the same enum type.</p>
<pre class="example"><code>(enum-set-contains? (enum-set color-red color-blue) color-red)
 &rArr; #t
(enum-set-contains? (enum-set color-red color-blue) color-orange)
 &rArr; #f
</code></pre>
<p><code>(list-&gt;enum-set</code>&nbsp;<em>list</em><code>)</code></p>
<p>Returns an enum-set containing the members of <em>list</em>. It is an error
unless all the members are enums belonging to the same enum type. It is also an
error if <em>list</em> is empty, since the relevant enum type cannot be
determined.</p>
<pre class="example"><code>(list-&gt;enum-set (enum-type-enums pizza))
 = (enum-type-&gt;enum-set pizza)

(enum-set-contains? (list-&gt;enum-set (list pizza-funghi pizza-chicago))
                    pizza-funghi)
 &rArr; #t
</code></pre>
<p><code>(enum-set-project</code>&nbsp;<em>enum-type
enum-set</em><code>)</code></p>
<p>Returns an enum set containing the enums belonging to <em>enum-type</em>
that have the same names as the members of <em>enum-set</em>, whose enum type
typically is not the same as <em>enum-type</em>.</p>
<p><code>(enum-set-copy</code>&nbsp;<em>enum-set</em><code>)</code></p>
<p>Returns a copy of <em>enum-set</em>.</p>
<h3 id="enum-set-predicates">Enum set predicates</h3>
<p><code>(enum-set?</code>&nbsp;<em>obj</em><code>)</code></p>
<p>Returns <code>#t</code> if <em>obj</em> is an enum set and <code>#f</code>
otherwise.</p>
<p><code>(enum-set-contains?</code>&nbsp;<em>enum-set
enum</em><code>)</code></p>
<p>Returns <code>#t</code> if <em>enum</em> is a member of <em>enum-set</em>.
It is an error if <em>enum</em> does not belong to the same enum type as the
members of <em>enum-set</em>.</p>
<pre class="example"><code>(enum-set-contains? color-set color-blue) &rArr; #t
(enum-set-contains? (enum-set-delete! color-set color-blue) color-blue) &rArr; #f
</code></pre>
<p><code>(enum-set-empty?</code>&nbsp;<em>enum-set</em><code>)</code></p>
<p>Returns <code>#t</code> if <em>enum-set</em> is empty,
and <code>#f</code> otherwise.</p>
<pre class="example"><code>(enum-set-empty? color-set) &rArr; #f
(enum-set-empty? (enum-set-delete-all! color-set (enum-set->list color-set)))
 &rArr; #t
</code></pre>
<p><code>(enum-set-disjoint?</code>&nbsp;<em>enum-set<sub>1</sub> enum-set<sub>2</sub></em><code>)</code></p>
<p>Returns <code>#t</code> if <em>enum-set<sub>1</sub></em> and <em>enum-set<sub>2</sub></em>
do not have any enum objects in common, and <code>#f</code> otherwise.</p>
<pre class="example"><code>(define reddish
  (list-&gt;enum-set (map (lambda (name)
                         (enum-name-&gt;enum color name))
                       '(red orange))))

(define ~reddish
  (list-&gt;enum-set (map (lambda (name)
                         (enum-name-&gt;enum color name))
                       '(yellow green cyan blue violet))))

(enum-set-disjoint? color-set reddish) &rArr; #f
(enum-set-disjoint? reddish ~reddish) &rArr; #t
</code></pre>
<p><code>(enum-set-contains?</code>&nbsp;<em>enum-set
enum</em><code>)</code></p>
<p>Returns <code>#t</code> if <em>enum</em> is a member of <em>enum-set</em>.
It is an error if <em>enum</em> does not belong to the same enum type as the
members of <em>enum-set</em>.</p>
<p>Note that the following three procedures do not obey the trichotomy law,
and cannot be used to define a comparator.</p>
<p><code>(enum-set=?</code>&nbsp;<em>enum-set-1 enum-set-2</em><code>)</code><br/>
<code>(enum-set&lt;?</code>&nbsp;<em>enum-set-1 enum-set-2</em><code>)</code><br/>
<code>(enum-set&gt;?</code>&nbsp;<em>enum-set-1 enum-set-2</em><code>)</code><br/>
<code>(enum-set&lt;=?</code>&nbsp;<em>enum-set-1 enum-set-2</em><code>)</code><br/>
<code>(enum-set&gt;=?</code>&nbsp;<em>enum-set-1 enum-set-2</em><code>)</code></p>
<p>Returns <code>#t</code> if the members of <em>enum-set-1</em>
are the same as / a proper subset of / a proper superset of/
a subset of / a superset of
<em>enum-set-2</em>.
It is an error if the members of the enum sets do not belong
to the same type.</p>
<pre class="example"><code>(enum-set=? color-set (enum-set-copy color-set)) &rArr; #t
(enum-set=? color-set reddish) &rArr; #f
(enum-set&lt;? reddish color-set) &rArr; #t
(enum-set&gt;? reddish color-set) &rArr; #f
(enum-set&lt;=? reddish color-set) &rArr; #t
(enum-set&gt;=? reddish color-set) &rArr; #f
</code></pre>
<p><code>(enum-set-any?</code>&nbsp;<em>pred enum-set</em><code>)</code><br/>
<code>(enum-set-every?</code>&nbsp;<em>pred enum-set</em><code>)</code></p>
<p>Returns <code>#t</code> if any/every application of <em>proc</em>
to the elements of <em>enum-set</em> returns true,
and <code>#f</code> otherwise.</p>
<pre class="example"><code>(enum-set-any? (lambda (e) (eqv? 'green (enum-name e)))
               color-set)
 &rArr; #t
(enum-set-any? (lambda (e) (eqv? 'green (enum-name e)))
               reddish)
 &rArr; #f
(enum-set-every? (lambda (e) (eq? 'green (enum-name e)))
                 color-set)
 &rArr; #f
(enum-set-every? (lambda (e) (string? (enum-value e)))
                 pizza-set)
 &rArr; #t
</code></pre>
<h3 id="enum-set-mutators">Enum set mutators</h3>
<p>These procedures are linear-update: that is, they may or may not modify
their <em>enum-set</em> argument, and any existing references to it are
invalidated.</p>
<p><code>(enum-set-adjoin!</code>&nbsp;<em>enum-set enum</em>
…<code>)</code></p>
<p>Returns an enum-set that contains the members of <em>enum-set</em> and the
<em>enums</em>. It is an error if the members of the result do not all belong
to the same enum type.</p>
<pre class="example"><code>(define reddish+blue
  (enum-set-adjoin! (enum-set-copy reddish) color-blue))

(enum-set&lt;? reddish reddish+blue) &rArr; #t
(enum-set-contains? reddish+blue color-blue) &rArr; #t
</code></pre>
<p><code>(enum-set-delete!</code>&nbsp;<em>enum-set enum</em>
…<code>)</code></p>
<p>Returns an enum-set that contains the members of <em>enum-set</em> excluding
the <em>enums</em>.</p>
<pre class="example"><code>(define no-blue
  (enum-set-delete! (enum-set-copy color-set) color-blue))

(enum-set&lt;? no-blue color-set) &rArr; #t
(enum-set-contains? no-blue color-blue) &rArr; #f
</code></pre>
<p><code>(enum-set-delete-all!</code>&nbsp;<em>enum-set list</em>
…<code>)</code></p>
<p>Returns an enum-set that contains the members of <em>enum-set</em> excluding
the members of <em>list</em>.</p>
<pre class="example"><code>(define empty-colors
  (enum-set-delete-all! (enum-set-copy color-set)
                        (enum-set-&gt;list color-set)))

(enum-set&lt;? empty-colors reddish) &rArr; #t
(enum-set-empty? empty-colors) &rArr; #t
</code></pre>
<h3 id="enum-set-operations">Enum set operations</h3>
<p><code>(enum-set-size</code>&nbsp;<em>enum-set</em><code>)</code></p>
<p>Returns the number of elements in <em>enum-set</em>.</p>
<pre class="example"><code>(enum-set-size (enum-set color-red color-blue)) &rArr; 2
</code></pre>
<p><code>(enum-set-&gt;list</code>&nbsp;<em>enum-set</em><code>)</code></p>
<p>Returns a list containing the members of <em>enum-set</em>.</p>
<pre class="example"><code>(map enum-name (enum-set-&gt;list reddish)) &rArr; (red orange)
(list-&gt;enum-set (enum-set-&gt;list color-set)) &rArr; color-set
</code></pre>
<p><code>(enum-set-count</code>&nbsp;<em>pred enum-set</em><code>)</code></p>
<p>Returns an exact integer, the number of elements of <em>enum-set</em>
that satisfy <em>pred</em>.</p>
<pre class="example"><code>(enum-set-count (lambda (e) (&gt; (enum-ordinal e) 3))
                color-set)
 &rArr; 3
</code></pre>
<p><code>(enum-set-filter</code>&nbsp;<em>pred enum-set</em><code>)</code><br/>
<code>(enum-set-remove</code>&nbsp;<em>pred enum-set</em><code>)</code></p>
<p>Returns an enum-set containing the enums in <em>enum-set</em>
that satisfy / do not satisfy <em>pred</em>.</p>
<p><code>(enum-set-map->list</code>&nbsp;<em>proc enum-set</em><code>)</code></p>
<p>Invokes <em>proc</em> on each member of <em>enum-set</em> in increasing
ordinal order. The results are made into a list and returned.</p>
<pre class="example"><code>(enum-set-map-&gt;list enum-name
                    (enum-set-filter (lambda (e) (&gt; (enum-ordinal e) 3))
                                     color-set))
 &rArr; '(cyan blue violet)
</code></pre>
<p><code>(enum-set-for-each</code>&nbsp;<em>proc enum-set</em><code>)</code></p>
<p>Invokes <em>proc</em> on each member of <em>enum-set</em> in increasing
ordinal order and discards the rest. The result is an unspecified value.</p>
<pre class="example"><code>(let ((s ""))
  (begin
   (enum-set-for-each (lambda (e)
                        (set! s (string-append s (enum-value e) " ")))
                      (enum-set pizza-margherita pizza-chicago))
   s))
   &rArr; "tomato and mozzarella deep-dish "
</code></pre>
<p><code>(enum-set-fold</code>&nbsp;<em>proc nil enum-set</em><code>)</code></p>
<p>The current state is initialized to <em>nil</em>, and <em>proc</em> is
invoked on each element of <em>enum-set</em> in increasing ordinal order and
the current state, setting the current state to the result. The algorithm is
repeated until all the elements of <em>enum-set</em> have been processed. Then
the current state is returned.</p>
<pre class="example"><code>(enum-set-fold cons '() color-set)
 = (reverse (enum-set-&gt;list color-set))
</code></pre>
<h3 id="enum-set-logical-operations">Enum set logical operations</h3>
<p><code>(enum-set-union!</code>&nbsp;<em>enum-set-1
enum-set-2</em><code>)</code></p>
<p>Returns an enum-set containing all the elements of either
<em>enum-set-1</em> or <em>enum-set-2</em>. It is an error if all the elements
of the result do not belong to the same enum type. The contents of either or
both enum-sets may be destroyed in the process.</p>
<pre class="example"><code>(enum-set-map-&gt;list enum-name
                    (enum-set-union! (enum-set color-orange)
                                     (enum-set color-blue)))
 &rArr; (orange blue)

(enum-set=? color-set (enum-set-union! reddish ~reddish)) &rArr; #t
</code></pre>
<p><code>(enum-set-intersection!</code>&nbsp;<em>enum-set-1
enum-set-2</em><code>)</code></p>
<p>Returns an enum-set containing all the elements that appear in both
<em>enum-set-1</em> and <em>enum-set-2</em>. It is an error if all the elements
of the result do not belong to the same enum type. The contents of either or
both enum-sets may be destroyed in the process.</p>
<pre class="example"><code>(enum-set-empty? (enum-set-intersection! reddish ~reddish))
 &rArr; #t
</code></pre>
<p><code>(enum-set-difference!</code>&nbsp;<em>enum-set-1
enum-set-2</em><code>)</code></p>
<p>Returns an enum-set containing the elements of <em>enum-set-1</em> but not
<em>enum-set-2</em>. It is an error if all the elements of the result do not
belong to the same enum type. The contents of either or both enum-sets may be
destroyed in the process.</p>
<pre class="example"><code>(enum-set=? ~reddish (enum-set-difference! color-set reddish))
 &rArr; #t
</code></pre>
<p><code>(enum-set-xor!</code>&nbsp;<em>enum-set-1
enum-set-2</em><code>)</code></p>
<p>Returns an enum-set containing all the elements of either
<em>enum-set-1</em> or <em>enum-set-2</em> but not both. It is an error if all
the elements of the result do not belong to the same enum type. The contents of
either or both enum-sets may be destroyed in the process.</p>
<pre class="example"><code>(enum-set=? color-set (enum-set-xor! reddish ~reddish))
 &rArr; #t

(enum-set-empty? (enum-set-xor! reddish reddish)) &rArr; #t
</code></pre>

<h2>Implementation</h2>

The implementation of this SRFI is in its repository
(<a href="https://github.com/scheme-requests-for-implementation/srfi-209">Github</a>).

<h2>Acknowledgements</h2>

The Java <code>Enum</code> class
and the R6RS <code>(rnrs enums)</code> library
provide the main inspirations for this SRFI;
acknowledgement is due to their authors.
Thanks also to the participants on the SRFI mailing list.

<h2>Copyright</h2>
<p>&copy; 2020 John Cowan, Wolfgang Corcoran-Mathe.</p>

<p>
  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:</p>

<p>
  The above copyright notice and this permission notice (including the
  next paragraph) shall be included in all copies or substantial
  portions of the Software.</p>
<p>
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.</p>

  <hr>
  <address>Editor: <a
href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A.
Gleckler</a></address></body></html>
